-> Database is a collection of related data and data is a collection of facts and figures that can be processed to produce information. 

-> Mostly data represents recordable facts. 
-> Data aids in producing information, which is based on facts. For example, if we have data about marks obtained by all students, 
    we can then conclude about toppers and average marks.

-> A database management system stores data in such a way that it becomes easier to retrieve, manipulate, and produce information.




Characteristics:

-> Traditionally, data was organized in file formats. 
-> DBMS was a new concept then,and all the research was done to make it overcome the deficiencies in traditional style of data management. 


-> A modern DBMS has the following characteristics:

 Real-world entity: 
-> A modern DBMS is more realistic and uses real-world entities to design its architecture. 
-> It uses the behavior and attributes too. 
-> For example, a school database may use students as an entity and their age as an attribute.


 Relation-based tables: 
-> DBMS allows entities and relations among them to form tables. 
-> A user can understand the architecture of a database just by looking at the table names.


 Isolation of data and application: 
-> A database system is entirely different than its data. 
-> A database is an active entity, whereas data is said to be passive, on which the database works and organizes. 
-> DBMS also stores metadata, which is data about data, to ease its own process.


 Less redundancy: 
-> DBMS follows the rules of normalization, which splits a relation when any of its attributes is having redundancy in values. 
-> Normalization is a mathematically rich and scientific process that reduces data redundancy.


 ACID Properties: 
-> DBMS follows the concepts of Atomicity, Consistency, Isolation, and Durability (normally shortened as ACID). 
-> These concepts are applied on transactions, which manipulate data in a database. 
-> ACID properties help the database stay healthy in multi-transactional environments and in case of failure.



 Multiuser and Concurrent Access: 
-> DBMS supports multi-user environment and allows them to access and manipulate data in parallel. 
-> Though there are restrictions on transactions when users attempt to handle the same data item, but users are always unaware of them.


 Multiple views: 
-> DBMS offers multiple views for different users. 
-> A user who is in the Sales department will have a different view of database than a person working in the Production department. 
-> This feature enables the users to have a concentrate view of the database according to their requirements.


 Security: 
-> Features like multiple views offer security to some extent where users are unable to access data of other users and departments. 
-> DBMS offers methods to impose constraints while entering data into the database and retrieving the same at a later stage. 
-> DBMS offers many different levels of security features, which enables multiple users to have different views with different features. 

For example, a user in the Sales department cannot see the data that belongs to the Purchase department.

-> Additionally, it can also be managed how much data of the Sales department should be displayed to the user. 
-> Since a DBMS is not saved on the disk as traditional file systems, it is very hard for miscreants to break the code.



Users:

-> A typical DBMS has users with different rights and permissions who use it for different purposes. 
-> Some users retrieve data and some back it up. 


-> The users of a DBMS can be broadly categorized as follows:

 Administrators: 
-> Administrators maintain the DBMS and are responsible for administrating the database. 
-> They are responsible to look after its usage and by whom it should be used. 
-> They create access profiles for users and apply limitations to maintain isolation and force security. 
-> Administrators also look after DBMS resources like system license, required tools, and other software and hardware related maintenance.


 Designers: 
-> Designers are the group of people who actually work on the designing part of the database. 
-> They keep a close watch on what data should be kept and in what format. 
-> They identify and design the whole set of entities, relations, constraints, and views.


 End Users: 
-> End users are those who actually reap the benefits of having a DBMS.
-> End users can range from simple viewers who pay attention to the logs or market rates to sophisticated users such as business analysts.





ARCHITECTURE:

-> The design of a DBMS depends on its architecture. 
-> It can be centralized or decentralized or hierarchical. 
-> The architecture of a DBMS can be seen as either single tier or multi-tier. 

-> An n-tier architecture divides the whole system into related but independent n modules, which can be independently modified, altered, changed, or replaced.


1-tier Architecture

-> In 1-tier architecture, the DBMS is the only entity where the user directly sits on the DBMS and uses it. 
-> Any changes done here will directly be done on the DBMS itself. 
-> It does not provide handy tools for end-users. 
-> Database designers and programmers normally prefer to use single-tier architecture.



2-tier Architecture:

-> If the architecture of DBMS is 2-tier, then it must have an application through which the DBMS can be accessed. 
-> Programmers use 2-tier architecture where they access the DBMS by means of an application. 
-> Here the application tier is entirely independent of the database in terms of operation, design, and programming.


3-tier Architecture:

-> A 3-tier architecture separates its tiers from each other based on the complexity of the users and how they use the data present in the database. 
-> It is the most widely used architecture to design a DBMS.



 Database (Data) Tier: 
-> At this tier, the database resides along with its query processing languages. 
-> We also have the relations that define the data and their constraints at this level.


 Application (Middle) Tier: 
-> At this tier reside the application server and the programs that access the database. 
-> For a user, this application tier presents an abstracted view of the database. 

-> End-users are unaware of any existence of the database beyond the application. 
-> At the other end, the database tier is not aware of any other user beyond the application tier. 

-> Hence, the application layer sits in the middle and acts as a mediator between the end-user and the database.


 User (Presentation) Tier: 
-> End-users operate on this tier and they know nothing about any existence of the database beyond this layer. 
-> At this layer, multiple views of the database can be provided by the application. 
-> All views are generated by applications that reside in the application tier.



Notes:
-> Multiple-tier database architecture is highly modifiable, as almost all its components are independent and can be changed independently.




DATA MODELS:

-> Data models define how the logical structure of a database is modeled. 
-> Data Models are fundamental entities to introduce abstraction in a DBMS. 
-> Data models define how data is connected to each other and how they are processed and stored inside the system.


-> The very first data model could be flat data-models, where all the data used are to be kept in the same plane. 
-> Earlier data models were not so scientific, hence they were prone to introduce lots of duplication and update anomalies.



Entity-Relationship Model:

-> Entity-Relationship (ER) Model is based on the notion of real-world entities and relationships among them. 
-> While formulating real-world scenario into the database model, the ER Model creates entity set, relationship set, general attributes, and constraints.


ER Model is best used for the conceptual design of a database.

ER Model is based on:
 Entities and their attributes.
 Relationships among entities.


These concepts are explained below.

 Entity
-> An entity in an ER Model is a real-world entity having properties called attributes. 
-> Every attribute is defined by its set of values called domain.

For example, in a school database, a student is considered as an entity. 

Student has various attributes like name, age, class, etc.


 Relationship
-> The logical association among entities is called relationship. 

-> Relationships are mapped with entities in various ways. 

-> Mapping cardinalities define the number of association between two entities.

Mapping cardinalities:
o one to one
o one to many
o many to one
o many to many




Relational Model:

-> The most popular data model in DBMS is the Relational Model. 
-> It is more scientific a model than others. 
-> This model is based on first-order predicate logic and defines a table as an n-ary relation.


The main highlights of this model are:
 Data is stored in tables called relations.
 Relations can be normalized.
 In normalized relations, values saved are atomic values.
 Each row in a relation contains a unique value.
 Each column in a relation contains values from a same domain.



DATA SCHEMAS:

-> A database schema is the skeleton structure that represents the logical view of the entire database. 
-> It defines how the data is organized and how the relations among them are associated. 
-> It formulates all the constraints that are to be applied on the data.


-> A database schema defines its entities and the relationship among them. 
-> It contains a descriptive detail of the database, which can be depicted by means of schema diagrams. 

-> It’s the database designers who design the schema to help programmers understand the database and make it useful. 


A database schema can be divided broadly into two categories:

 Physical Database Schema: 
-> This schema pertains to the actual storage of data and its form of storage like files, indices, etc. 
-> It defines how the data will be stored in a secondary storage.

 Logical Database Schema: 
-> This schema defines all the logical constraints that need to be applied on the data stored. 
-> It defines tables, views, and integrity constraints.




Database Instance:

-> It is important that we distinguish these two terms individually. 
-> Database schema is the skeleton of database. 
-> It is designed when the database doesn't exist at all. 
-> Once the database is operational, it is very difficult to make any changes to it. 

-> A database schema does not contain any data or information.
-> A database instance is a state of operational database with data at any given time. 

-> It contains a snapshot of the database. Database instances tend to change with time. 
-> A DBMS ensures that its every instance (state) is in a valid state, by diligently following all the validations, constraints, and conditions that the 
            database designers have imposed.



DATA INDEPENDENCE;

-> If a database system is not multi-layered, then it becomes difficult to make any changes in the database system. 
-> Database systems are designed in multi-layers as we learnt earlier.



Data Independence:

-> A database system normally contains a lot of data in addition to users’ data. 

-> For example, it stores data about data, known as metadata, to locate and retrieve data easily. 
-> It is rather difficult to modify or update a set of metadata once it is stored in the database. 
-> But as a DBMS expands, it needs to change over time to satisfy the requirements of the users. 
-> If the entire data is dependent, it would become a tedious and highly complex job.


-> Metadata itself follows a layered architecture, so that when we change data at one layer, it does not affect the data at another level.
-> This data is independent but mapped to each other.


Logical Data Independence:

-> Logical data is data about database, that is, it stores information about how data is managed inside. 
-> For example, a table (relation) stored in the database and all its constraints applied on that relation.

-> Logical data independence is a kind of mechanism, which liberalizes itself from actual data stored on the disk. 
-> If we do some changes on table format, it should not change the data residing on the disk.


Physical Data Independence:

-> All the schemas are logical, and the actual data is stored in bit format on the disk. 
-> Physical data independence is the power to change the physical data without impacting the schema or logical data.

-> For example, in case we want to change or upgrade the storage system itself —suppose we want to replace hard-disks with SSD — it should not have any 
        impact on the logical data or schemas.





ER MODEL – BASIC CONCEPTS:

-> The ER model defines the conceptual view of a database. 
-> It works around real-world entities and the associations among them. 
-> At view level, the ER model is considered a good option for designing databases.



Entity:

-> An entity can be a real-world object, either animate or inanimate, that can be easily identifiable. 
-> For example, in a school database, students, teachers, classes, and courses offered can be considered as entities. 

-> All these entities have some attributes or properties that give them their identity.

-> An entity set is a collection of similar types of entities. 
-> An entity set may contain entities with attribute sharing similar values. 

-> For example, a Students set may contain all the students of a school; likewise a Teachers set may contain all the teachers of a school from all faculties. 
-> Entity sets need not be disjoint.



Attributes:

-> Entities are represented by means of their properties called attributes. 
-> All attributes have values. 
-> For example, a student entity may have name, class, and age as attributes.

-> There exists a domain or range of values that can be assigned to attributes. 
-> For example, a student's name cannot be a numeric value. It has to be alphabetic. 

-> A student's age cannot be negative, etc.


Types of Attributes:

 Simple attribute: 
-> Simple attributes are atomic values, which cannot be divided further. 
-> For example, a student's phone number is an atomic value of 10 digits.


 Composite attribute: 
-> Composite attributes are made of more than one simple attribute. 
-> For example, a student's complete name may have first_name and last_name.


 Derived attribute: 
-> Derived attributes are the attributes that do not exist in the physical database, but their values are derived from other attributes present in the database. 
-> For example, average_salary in a department should not be saved directly in the database, instead it can be derived. 
-> For another example, age can be derived from data_of_birth.


 Single-value attribute: 
-> Single-value attributes contain single value. 
-> For example: Social_Security_Number.


 Multi-value attribute: 
-> Multi-value attributes may contain more than one values. 
-> For example, a person can have more than one phone number, email_address, etc.


These attribute types can come together in a way like:
 simple single-valued attributes
 simple multi-valued attributes
 composite single-valued attributes
 composite multi-valued attributes





Entity-Set and Keys:

-> Key is an attribute or collection of attributes that uniquely identifies an entity among entity set.
-> For example, the roll_number of a student makes him/her identifiable among students.


 Super Key: 
-> A set of attributes (one or more) that collectively identifies an entity in an entity set.


 Candidate Key: 
-> A minimal super key is called a candidate key. 
-> An entity set may have more than one candidate key.


 Primary Key:
-> A primary key is one of the candidate keys chosen by the database designer to uniquely identify the entity set.




Relationship:

-> The association among entities is called a relationship. 
-> For example, an employee works_at a department, a student enrolls in a course. 
-> Here, Works_at and Enrolls are called relationships.


Relationship Set:

-> A set of relationships of similar type is called a relationship set. 
-> Like entities, a relationship too can have attributes. 
-> These attributes are called descriptive attributes.


Degree of Relationship:

-> The number of participating entities in a relationship defines the degree of the relationship.
 Binary = degree 2
 Ternary = degree 3
 n-ary = degree n




Mapping Cardinalities:

-> Cardinality defines the number of entities in one entity set, which can be associated with the number of entities of other set via relationship set.


 One-to-one: 
-> One entity from entity set A can be associated with at most one entity of entity set B and vice versa.


 One-to-many: 
-> One entity from entity set A can be associated with more than one entities of entity set B, 
            however an entity from entity set B can be associated with at most one entity.



 Many-to-one: 
-> More than one entities from entity set A can be associated with at most one entity of entity set B, 
            however an entity from entity set B can be associated with more than one entity from entity set A.



 Many-to-many: 
-> One entity from A can be associated with more than one entity from B and vice versa.





ER DIAGRAM REPRESENTATION:

-> Let us now learn how the ER Model is represented by means of an ER diagram. 
-> Any object, for example, entities, attributes of an entity, relationship sets, and attributes of relationship sets, 
        can be represented with the help of an ER diagram.




Entity:

-> Entities are represented by means of rectangles. 
-> Rectangles are named with the entity set they represent.



Attributes:

-> Attributes are the properties of entities. 
-> Attributes are represented by means of ellipses. 
-> Every ellipse represents one attribute and is directly connected to its entity (rectangle).


-> If the attributes are composite, they are further divided in a tree like structure. 
-> Every node is then connected to its attribute. 
-> That is, composite attributes are represented by ellipses that are connected with an ellipse.


-> Multivalued attributes are depicted by double ellipse.
-> Derived attributes are depicted by dashed ellipse.




Relationship:

-> Relationships are represented by diamond-shaped box.
-> Name of the relationship is written inside the diamond-box. 
-> All the entities (rectangles) participating in a relationship are connected to it by a line.




Binary Relationship and Cardinality:

-> A relationship where two entities are participating is called a binary relationship. 
-> Cardinality is the number of instance of an entity from a relation that can be associated with the relation.


 One-to-one: 
-> When only one instance of an entity is associated with the relationship, it is marked as '1:1'.

-> The following image reflects that only one instance of each entity should be associated with the relationship. 
-> It depicts one-to-one relationship.



 One-to-many: 
-> When more than one instance of an entity is associated with a relationship, it is marked as '1:N'. 

-> The following image reflects that only one instance of entity on the left and more than 
        one instance of an entity on the right can be associated with the relationship. 
-> It depicts one-to-many relationship.



 Many-to-one: 
-> When more than one instance of entity is associated with the relationship, it is marked as 'N:1'. 

-> The following image reflects that more than one instance of an entity on the left and only 
    one instance of an entity on the right can be associated with the relationship. 
-> It depicts many-to-one relationship.


 Many-to-many: 
-> The following image reflects that more than one instance of an entity on the left and more than one instance of an entity on the 
    right can be associated with the relationship. 
-> It depicts many-to-many relationship.



Participation Constraints:

 Total Participation: 
-> Each entity is involved in the relationship. 
-> Total participation is represented by double lines.


 Partial participation: 
-> Not all entities are involved in the relationship. 
-> Partial participation is represented by single lines.




GENERALIZATION & SPECIALIZATION:

-> The ER Model has the power of expressing database entities in a conceptual hierarchical manner. 
-> As the hierarchy goes up, it generalizes the view of entities, and as we go deep in the hierarchy, it gives us the detail of every entity included.


Generalization:

-> As mentioned above, the process of generalizing entities, 
        where the generalized entities contain the properties of all the generalized entities, is called generalization.
-> In generalization, a number of entities are brought together into one generalized entity based on their similar characteristics. 

-> For example, pigeon, house sparrow, crow, and dove can all be generalized as Birds.


Specialization:

-> Specialization is the opposite of generalization. 
-> In specialization, a group of entities is divided into sub-groups based on their characteristics. 
-> Take a group ‘Person’ for example. 

-> A person has name, date of birth, gender, etc. 
-> These properties are common in all persons, human beings. 

-> But in a company, persons can be identified as employee, employer, customer, or vendor, based on what role they play in the company.

-> Similarly, in a school database, persons can be specialized as teacher, student,or a staff, based on what role they play in school as entities.




Inheritance:

-> We use all the above features of ER-Model in order to create classes of objects in object-oriented programming. 
-> The details of entities are generally hidden from the user; this process known as abstraction.

-> Inheritance is an important feature of Generalization and Specialization. 
-> It allows lower-level entities to inherit the attributes of higher-level entities.

-> For example, the attributes of a Person class such as name, age, and gender can be inherited by lower-level entities such as Student or Teacher.



CODD’S 12 RULES:

-> Dr Edgar F. Codd, after his extensive research on the Relational Model of database systems, came up with twelve rules of his own, which according to 
        him, a database must obey in order to be regarded as a true relational database.

-> These rules can be applied on any database system that manages stored data using only its relational capabilities. 
-> This is a foundation rule, which acts as a base for all the other rules. 




Rule 1: Information Rule

-> The data stored in a database, may it be user data or metadata, must be a value of some table cell. 
-> Everything in a database must be stored in a table format. 


Rule 2: Guaranteed Access Rule

-> Every single data element (value) is guaranteed to be accessible logically with a combination of table-name, primary-key (row value), 
        and attribute-name (column value). 
-> No other means, such as pointers, can be used to access data.



Rule 3: Systematic Treatment of NULL Values

-> The NULL values in a database must be given a systematic and uniform treatment. 
-> This is a very important rule because a NULL can be interpreted as one the following: data is missing, data is not known, or data is not applicable.



Rule 4: Active Online Catalog

-> The structure description of the entire database must be stored in an online catalog, known as data dictionary, which can be accessed by authorized users. 
-> Users can use the same query language to access the catalog which they use to access the database itself.



Rule 5: Comprehensive Data Sub-Language Rule

-> A database can only be accessed using a language having linear syntax that supports data definition, data manipulation, and transaction management operations. 
-> This language can be used directly or by means of some application. 
-> If the database allows access to data without any help of this language, then it is considered as a violation.


Rule 6: View Updating Rule

-> All the views of a database, which can theoretically be updated, must also be updatable by the system.


Rule 7: High-Level Insert, Update, and Delete Rule

-> A database must support high-level insertion, updation, and deletion. 
-> This must not be limited to a single row, that is, it must also support union, intersection and minus operations to yield sets of data records.


Rule 8: Physical Data Independence

-> The data stored in a database must be independent of the applications that access the database. 
-> Any change in the physical structure of a database must not have any impact on how the data is being accessed by external applications.


Rule 9: Logical Data Independence
-> The logical data in a database must be independent of its user’s view (application). 
-> Any change in logical data must not affect the applications using it. 

-> For example, if two tables are merged or one is split into two different tables, 
        there should be no impact or change on the user application. 
-> This is one of the most difficult rule to apply.



Rule 10: Integrity Independence
-> A database must be independent of the application that uses it. 
-> All its integrity constraints can be independently modified without the need of any change in the application. 
-> This rule makes a database independent of the front-end application and its interface.


Rule 11: Distribution Independence
-> The end-user must not be able to see that the data is distributed over various locations. 
-> Users should always get the impression that the data is located at one site only. 
-> This rule has been regarded as the foundation of distributed database systems.


Rule 12: Non-Subversion Rule

-> If a system has an interface that provides access to low-level records, 
        then the interface must not be able to subvert the system and bypass security and integrity constraints.




RELATIONAL DATA MODEL:

-> Relational data model is the primary data model, which is used widely around the world for data storage and processing. 
-> This model is simple and it has all the properties and capabilities required to process data with storage efficiency.



Concepts:

1. Tables: 
-> In relational data model, relations are saved in the format of Tables. 
-> This format stores the relation among entities. 
-> A table has rows and columns, where rows represent records and columns represent the attributes.


2. Tuple: 
-> A single row of a table, which contains a single record for that relation is called a tuple.


3. Relation instance: 
-> A finite set of tuples in the relational database system represents relation instance. 
-> Relation instances do not have duplicate tuples.


4. Relation schema: 
-> A relation schema describes the relation name (table name), attributes, and their names.


5. Relation key: 
-> Each row has one or more attributes, known as relation key,which can identify the row in the relation (table) uniquely.


6. Attribute domain: 
-> Every attribute has some predefined value scope, known as attribute domain.




Constraints:

-> Every relation has some conditions that must hold for it to be a valid relation. 
-> These conditions are called Relational Integrity Constraints. 


There are three main integrity constraints:
 Key constraints
 Domain constraints
 Referential integrity constraints



1. Key Constraints
-> There must be at least one minimal subset of attributes in the relation, which can identify a tuple uniquely. 
-> This minimal subset of attributes is called key for that relation. 
-> If there are more than one such minimal subsets, these are called candidate keys.


Key constraints force that:
 in a relation with a key attribute, no two tuples can have identical valuesfor key attributes.
 a key attribute cannot have NULL values.

Notes:
-> Key constraints are also referred to as Entity Constraints.



Domain Constraints:

-> Attributes have specific values in real-world scenario. 
-> For example, age can only be a positive integer. 
-> The same constraints have been tried to employ on the attributes of a relation. 
-> Every attribute is bound to have a specific range of values. 
-> For example, age cannot be less than zero and telephone numbers cannot contain a digit outside 0-9.


Referential Integrity Constraints:

-> Referential integrity constraints work on the concept of Foreign Keys. 
-> A foreign key is a key attribute of a relation that can be referred in other relation. 
-> Referential integrity constraint states that if a relation refers to a key attribute of a different or same relation, then that key element must exist.



RELATIONAL ALGEBRA:

-> Relational database systems are expected to be equipped with a query language that can assist its users to query the database instances. 

-> There are two kinds of query languages: relational algebra and relational calculus.



Relational Algebra:

-> Relational algebra is a procedural query language, which takes instances of relations as input and yields instances of relations as output. 
-> It uses operators to perform queries. 
-> An operator can be either unary or binary. 
-> They accept relations as their input and yield relations as their output. 
-> Relational algebra is performed recursively on a relation and intermediate results are also considered relations.


The fundamental operations of relational algebra are as follows:
 Select
 Project
 Union
 Set different
 Cartesian product
 Rename



Select Operation (σ)

-> It selects tuples that satisfy the given predicate from a relation.

Notation: σp(r)

Where σ stands for selection predicate and r stands for relation. 

-> p is prepositional logic formula which may use connectors like and, or, and not. 

-> These terms may use relational operators like: =, ≠, ≥, <, >, ≤.
For example:
σsubject="database"(Books)
Output: Selects tuples from books where subject is 'database'.

σsubject="database" and price="450"(Books)
Output: Selects tuples from books where subject is 'database' and 'price' is 450.

σsubject="database" and price < "450" or year > "2010"(Books)
Output: Selects tuples from books where subject is 'database' and 'price' is 450 or those books published after 2010.




Project Operation (∏)
-> It projects column(s) that satisfy a given predicate.

Notation: ∏A1, A2, An (r)
Where A1, A2, An are attribute names of relation r.

-> Duplicate rows are automatically eliminated, as relation is a set.
For example:
∏subject, author (Books)

-> Selects and projects columns named as subject and author from the relation Books.




Union Operation (∪)
-> It performs binary union between two given relations and is defined as:
r ∪ s = { t | t ∈ r or t ∈ s}

Notion: r U s

Where r and s are either database relations or relation result set (temporary relation).

->For a union operation to be valid, the following conditions must hold:
 r and s must have the same number of attributes.
 Attribute domains must be compatible.
 Duplicate tuples are automatically eliminated.

∏ author (Books) ∪ ∏ author (Articles)

Output: Projects the names of the authors who have either written a book or an article or both.





Set Difference (−)

-> The result of set difference operation is tuples, which are present in one relation but are not in the second relation.

Notation: r − s

Finds all the tuples that are present in r but not in s.

∏author(Books) − ∏author(Articles)
Output: Provides the name of authors who have written books but not articles.




Cartesian Product (Χ)

-> Combines information of two different relations into one.
Notation: r Χ s

Where r and s are relations and their output will be defined as:

r Χ s = { q t | q ∈ r and t ∈ s}

∏author = 'tutorialspoint'(Books Χ Articles)

Output: Yields a relation, which shows all the books and articles written by tutorialspoint.




Rename Operation (ρ)
-> The results of relational algebra are also relations but without any name. 
-> The rename operation allows us to rename the output relation. ‘rename’ operation is denoted with small Greek letter rho ρ.


Notation: ρ x (E)
Where the result of expression E is saved with name of x.

Additional operations are:
 Set intersection
 Assignment
 Natural join



Relational Calculus:

-> In contrast to Relational Algebra, Relational Calculus is a non-procedural query language, that is, it tells what to do but never explains how to do it.


Relational calculus exists in two forms:


Tuple Relational Calculus (TRC):

Filtering variable ranges over tuples

Notation: {T | Condition}

Returns all tuples T that satisfies a condition.


For example:
{ T.name | Author(T) AND T.article = 'database' }

Output: Returns tuples with 'name' from Author who has written article on 
'database'.

TRC can be quantified. We can use Existential (∃) and Universal Quantifiers (∀).

For example:
{ R| ∃T ∈ Authors(T.article='database' AND R.name=T.name)}

Output: The above query will yield the same result as the previous one.




Domain Relational Calculus (DRC):

-> In DRC, the filtering variable uses the domain of attributes instead of entire tuple values (as done in TRC, mentioned above).

Notation:
{ a1, a2, a3, ..., an | P (a1, a2, a3, ... ,an)}
Where a1, a2 are attributes and P stands for formulae built by inner attributes.

For example:
{< article, page, subject > | ∈ TutorialsPoint ∧ subject = 'database'}

Output: Yields Article, Page, and Subject from the relation TutorialsPoint, where subject is database.


-> Just like TRC, DRC can also be written using existential and universal quantifiers. 

DRC also involves relational operators.

The expression power of Tuple Relation Calculus and Domain Relation Calculus is equivalent to Relational Algebra.





ER MODEL TO RELATIONAL MODEL:

-> ER Model, when conceptualized into diagrams, gives a good overview of entity-relationship, which is easier to understand. 
-> ER diagrams can be mapped to relational schema, that is, it is possible to create relational schema using ER diagram. 
-> We cannot import all the ER constraints into relational model, but an approximate schema can be generated.


-> There are several processes and algorithms available to convert ER Diagrams into Relational Schema. 

-> Some of them are automated and some of them are manual. 

-> We may focus here on the mapping diagram contents to relational basics.



ER diagrams mainly comprise of:
 Entity and its attributes
 Relationship, which is association among entities




Mapping Entity:

-> An entity is a real-world object with some attributes.


Mapping Process (Algorithm):
 Create table for each entity.
 Entity's attributes should become fields of tables with their respective data types.
 Declare primary key.



Mapping Relationship:

-> A relationship is an association among entities.



Mapping Process:
 Create table for a relationship.
 Add the primary keys of all participating Entities as fields of table with their respective data types.
 If relationship has any attribute, add each attribute as field of table.
 Declare a primary key composing all the primary keys of participating entities.
 Declare all foreign key constraints.



Mapping Weak Entity Sets:

-> A weak entity set is one which does not have any primary key associated with it.


Mapping Process:
 Create table for weak entity set.
 Add all its attributes to table as field.
 Add the primary key of identifying entity set.
 Declare all foreign key constraints.



Mapping Hierarchical Entities:

-> ER specialization or generalization comes in the form of hierarchical entity sets.



Mapping Process:

 Create tables for all higher-level entities.
 Create tables for lower-level entities.
 Add primary keys of higher-level entities in the table of lower-level entities.
 In lower-level tables, add all other attributes of lower-level entities.
 Declare primary key of higher-level table and the primary key for lower-level table.
 Declare foreign key constraints.



SQL OVERVIEW:

-> SQL is a programming language for Relational Databases. 
-> It is designed over relational algebra and tuple relational calculus. 
-> SQL comes as a package with all major distributions of RDBMS.

-> SQL comprises both data definition and data manipulation languages. 
-> Using the data definition properties of SQL, one can design and modify database schema,
        whereas data manipulation properties allows SQL to store and retrieve data from database.



Data Definition Language:

SQL uses the following set of commands to define database schema:

CREATE:
Creates new databases, tables, and views from RDBMS.


For example:
Create database tutorialspoint;
Create table article;
Create view for_students;



DROP:
Drops commands, views, tables, and databases from RDBMS.

For example:
Drop object_type object_name;
Drop database tutorialspoint;
Drop table article;
Drop view for_students;




ALTER:
Modifies database schema.
Alter object_type object_name parameters;


For example:
Alter table article add subject varchar;

-> This command adds an attribute in the relation article with the name subject of string type.




Data Manipulation Language:

-> SQL is equipped with data manipulation language (DML). 
-> DML modifies the database instance by inserting, updating, and deleting its data. 
-> DML is responsible for all forms data modification in a database. 

SQL contains the following set of commands in its DML section:
 SELECT/FROM/WHERE
 INSERT INTO/VALUES
 UPDATE/SET/WHERE
 DELETE FROM/WHERE


-> These basic constructs allow database programmers and users to enter data and information into the database 
        and retrieve efficiently using a number of filter options.




SELECT/FROM/WHERE:

 SELECT
-> This is one of the fundamental query command of SQL. 
-> It is similar to the projection operation of relational algebra. 
-> It selects the attributes based on the condition described by WHERE clause.


 FROM
-> This clause takes a relation name as an argument from which attributes are to be selected/projected. 
-> In case more than one relation names are given, this clause corresponds to Cartesian product.


 WHERE
-> This clause defines predicate or conditions, which must match in order to qualify the attributes to be projected.

For example:
Select author_name
From book_author
Where age > 50;


-> This command will yield the names of authors from the relation book_author whose age is greater than 50.



INSERT INTO/VALUES:

-> This command is used for inserting values into the rows of a table (relation).


Syntax:
INSERT INTO table (column1 [, column2, column3 ... ]) VALUES (value1 [,value2, value3 ... ])

Or
INSERT INTO table VALUES (value1, [value2, ... ])

For example:
INSERT INTO tutorialspoint (Author, Subject) VALUES ("anonymous","computers");



UPDATE/SET/WHERE:

-> This command is used for updating or modifying the values of columns in a table (relation).

Syntax:
UPDATE table_name SET column_name = value [, column_name = value ...]
[WHERE condition]


For example:
UPDATE tutorialspoint SET Author="webmaster" WHERE Author="anonymous";




DELETE/FROM/WHERE:

-> This command is used for removing one or more rows from a table (relation).

Syntax:
DELETE FROM table_name [WHERE condition];


For example:
DELETE FROM tutorialspoint
 WHERE Author="unknown";




NORMALIZATION:

Functional Dependency:

-> Functional dependency (FD) is a set of constraints between two attributes in a relation. 
-> Functional dependency says that if two tuples have same values for attributes A1, A2,..., An, 
        then those two tuples must have to have same values for attributes B1, B2, ..., Bn.

-> Functional dependency is represented by an arrow sign (→) that is, X→Y, where X functionally determines Y. 
-> The left-hand side attributes determine the values of attributes on the right-hand side.




Armstrong's Axioms:

-> If F is a set of functional dependencies then the closure of F, denoted as F+, is the set of all functional dependencies logically implied by F. 

-> Armstrong's Axioms are a set of rules that, when applied repeatedly, generates a closure of functional dependencies.
 Reflexive rule: 
-> If alpha is a set of attributes and beta is_subset_of alpha, then alpha holds beta.

 Augmentation rule: 
-> If a → b holds and y is attribute set, then ay → by also holds. 
-> That is adding attributes in dependencies, does not change the basic dependencies.

 Transitivity rule: 
-> Same as transitive rule in algebra, if a → b holds and b → c holds, then a → c also holds. 
-> a → b is called as a functionally that determines b.



Trivial Functional Dependency:

 Trivial: 
-> If a functional dependency (FD) X → Y holds, where Y is a subset of X, then it is called a trivial FD. 
-> Trivial FDs always hold.

 Non-trivial: 
-> If an FD X → Y holds, where Y is not a subset of X, then it is called a non-trivial FD.

 Completely non-trivial: 
-> If an FD X → Y holds, where x intersect Y = Φ, it is said to be a completely non-trivial FD.




Normalization:

-> If a database design is not perfect, it may contain anomalies, which are like a bad dream for any database administrator. 
-> Managing a database with anomalies is next to impossible.

 Update anomalies: 
-> If data items are scattered and are not linked to each other properly, then it could lead to strange situations. 

For example, 
-> when we try to update one data item having its copies scattered over several places, 
        a few instances get updated properly while a few others are left with old values. 
-> Such instances leave the database in an inconsistent state.


 Deletion anomalies: 
-> We tried to delete a record, but parts of it was left undeleted because of unawareness, the data is also saved somewhere else.


 Insert anomalies: 
-> We tried to insert data in a record that does not exist at all.

Notes:
-> Normalization is a method to remove all these anomalies and bring the database to a consistent state.



First Normal Form:

-> First Normal Form is defined in the definition of relations (tables) itself. 
-> This rule defines that all the attributes in a relation must have atomic domains. 
-> The values in an atomic domain are indivisible units.

-> Each attribute must contain only a single value from its predefined domain.




Second Normal Form:

-> Before we learn about the second normal form, we need to understand the following:

 Prime attribute: 
-> An attribute, which is a part of the prime-key, is known as a prime attribute.


 Non-prime attribute: 
-> An attribute, which is not a part of the prime-key, is said to be a non-prime attribute.


-> If we follow second normal form, then every non-prime attribute should be fully functionally dependent on prime key attribute. 
-> That is, if X → A holds, then there should not be any proper subset Y of X for which Y → A also holds true.


-> We see here in Student_Project relation that the prime key attributes are Stu_ID and Proj_ID. 

-> According to the rule, non-key attributes, i.e., Stu_Name and Proj_Name must be dependent upon both and not on any of the prime key attribute individually. 
-> But we find that Stu_Name can be identified by Stu_ID and Proj_Name can be identified by Proj_ID independently. 
-> This is called partial dependency, which is not allowed in Second Normal Form.




Third Normal Form:

-> For a relation to be in Third Normal Form, it must be in Second Normal form and the following must satisfy:

 No non-prime attribute is transitively dependent on prime key attribute.
 For any non-trivial functional dependency, X → A, then either:
o X is a superkey or,
o A is prime attribute.



-> We find that in the above Student_detail relation, Stu_ID is the key and only prime key attribute. 
-> We find that City can be identified by Stu_ID as well as Zip itself. 
-> Neither Zip is a superkey nor is City a prime attribute. 
-> Additionally, Stu_ID → Zip → City, so there exists transitive dependency.




Boyce-Codd Normal Form:

-> Boyce-Codd Normal Form (BCNF) is an extension of Third Normal Form on strict terms. 

BCNF states that -
 For any non-trivial functional dependency, X → A, X must be a super-key.


-> In the above image, Stu_ID is the super-key in the relation Student_Detail and Zip is the super-key in the relation ZipCodes. 

-> So,
Stu_ID → Stu_Name, Zip
and
Zip → City
Which confirms that both the relations are in BCNF.




JOINS:

-> We understand the benefits of taking a Cartesian product of two relations, which gives us all the possible tuples that are paired together. 
-> But it might not be feasible for us in certain cases to take a Cartesian product 
        where we encounter huge relations with thousands of tuples having a considerable large number of attributes.
        
        
-> Join is a combination of a Cartesian product followed by a selection process. 
-> A Join operation pairs two tuples from different relations, if and only if a given join condition is satisfied.




Theta (θ) Join:

-> Theta join combines tuples from different relations provided they satisfy the theta condition. 
-> The join condition is denoted by the symbol θ.


Notation:
R1 ⋈θ R2

-> R1 and R2 are relations having attributes (A1, A2, .., An) and (B1, B2,.. ,Bn) such that the attributes don’t have anything in common, that is, R1 ∩ R2 = Φ.

-> Theta join can use all kinds of comparison operators.


Student:

SID     Name     Std
101     Alex     10
102     Maria    11



Subjects:

Class    Subject
10       Math
10       English
11       Music
11       Sports




Student_Detail = STUDENT ⋈Student.Std = Subject.Class SUBJECT


Student_detail

SID     Name     Std     Class    Subject
101     Alex     10      10       Math
101     Alex     10      10       English
102     Maria    11      11       Music
102     Maria    11      11       Sports



Equijoin:

-> When Theta join uses only equality comparison operator, it is said to be equijoin. 
-> The above example corresponds to equijoin.


Natural Join (⋈)

-> Natural join does not use any comparison operator. 
-> It does not concatenate the way a Cartesian product does. 
-> We can perform a Natural Join only if there is at least one common attribute that exists between two relations. 
-> In addition, the attributes must have the same name and domain.


-> Natural join acts on those matching attributes where the values of attributes in both the relations are same.


Courses:

CID      Course         Dept
CS01     Database       CS
ME01     Mechanics      ME
EE01     Electronics    EE


HoD:

Dept     Head
CS       Alex
ME       Maya
EE       Mira



Courses ⋈ HoD:

Dept    CID      Course       Head
CS      CS01     Database     Alex
ME      ME01     Mechanics    Maya
EE      EE01     Electronics  Mira




Outer Joins:

-> Theta Join, Equijoin, and Natural Join are called inner joins. 
-> An inner join includes only those tuples with matching attributes and the rest are discarded in the resulting relation. 

-> Therefore, we need to use outer joins to include all the tuples from the participating relations in the resulting relation. 

-> There are three kinds of outer joins: left outer join, right outer join, and full outer join.




Left Outer Join:

-> All the tuples from the Left relation, R, are included in the resulting relation. 
-> If there are tuples in R without any matching tuple in the Right relation S, then the S-attributes of the resulting relation are made NULL.


Left:

A       B
100     Database
101     Mechanics
102     Electronics


Right:

A       B
100     Alex
102     Maya
104     Mira



Courses HoD:

A        B               C       D
100      Database       100      Alex
101      Mechanics      ---      ---
102      Electronics    102      Maya



Right Outer Join:

-> All the tuples from the Right relation, S, are included in the resulting relation. 
-> If there are tuples in S without any matching tuple in R, then the R-attributes of resulting relation are made NULL.


Courses HoD
A        B            C       D
100      Database     100     Alex
102      Electronics  102     Maya
---      ---          104     Mira



Full Outer Join:

-> All the tuples from both participating relations are included in the resulting relation. 
-> If there are no matching tuples for both relations, their respective unmatched attributes are made NULL.


Courses HoD:
A       B           C        D
100     Database    100      Alex
101     Mechanics   ---      ---
102     Electronics 102      Maya
---     ---         104      Mira



STORAGE SYSTEM:

-> Databases are stored in file formats, which contain records. 
-> At physical level, the actual data is stored in electromagnetic format on some device. 


-> These storage devices can be broadly categorized into three types:

High Capacity -> Tertiary Memory > Seondary Memory > Primary Memory
High Speed    -> Primary Memory > Secondary Memory > Tertiary Memory



 Primary Storage: 
-> The memory storage that is directly accessible to the CPU comes under this category. 
-> CPU's internal memory (registers), fast memory (cache), and main memory (RAM) are directly accessible to the CPU, 
        as they are all placed on the motherboard or CPU chipset. 
-> This storage is typically very small, ultra-fast, and volatile. 
-> Primary storage requires continuous power supply in order to maintain its state. 
-> In case of a power failure, all its data is lost.


 Secondary Storage: 
-> Secondary storage devices are used to store data for future use or as backup. 
-> Secondary storage includes memory devicesthat are not a part of the CPU chipset or motherboard, 
-> for example, magnetic disks, optical disks (DVD, CD, etc.), hard disks, flash drives, and magnetic tapes.


 Tertiary Storage: 
-> Tertiary storage is used to store huge volumes of data. 
-> Since such storage devices are external to the computer system, they are the slowest in speed. 
-> These storage devices are mostly used to take the back up of an entire system. 
-> Optical disks and magnetic tapes are widely used as tertiary storage.




Memory Hierarchy:

-> A computer system has a well-defined hierarchy of memory. 
-> A CPU has direct access to it main memory as well as its inbuilt registers. 

-> The access time of the main memory is obviously less than the CPU speed. 
-> To minimize this speed mismatch, cache memory is introduced. 

-> Cache memory provides the fastest access time and it contains data that is most frequently accessed by the CPU. 
-> The memory with the fastest access is the costliest one. 

-> Larger storage devices offer slow speed and they are less expensive, however they can store huge volumes of data as compared to CPU registers or cache memory.




Magnetic Disks:

-> Hard disk drives are the most common secondary storage devices in present computer systems. 
-> These are called magnetic disks because they use the concept of magnetization to store information. 

-> Hard disks consist of metal disks coated with magnetizable material. 
-> These disks are placed vertically on a spindle. 
-> A read/write head moves in between the disks and is used to magnetize or de-magnetize the spot under it. 

-> A magnetized spot can be recognized as 0 (zero) or 1 (one).
-> Hard disks are formatted in a well-defined order to store data efficiently. 

-> A hard disk plate has many concentric circles on it, called tracks. 
-> Every track is further divided into sectors. 
-> A sector on a hard disk typically stores 512 bytes of data.



RAID:

-> RAID stands for Redundant Array of Independent Disks, which is a technology to connect multiple secondary storage devices and use them as a single storage media.
-> RAID consists of an array of disks in which multiple disks are connected together to achieve different goals. 
-> RAID levels define the use of disk arrays.


 RAID 0: 
-> In this level, a striped array of disks is implemented. 
-> The data is broken down into blocks and the blocks are distributed among disks. 
-> Each disk receives a block of data to write/read in parallel. 
-> It enhances the speed and performance of the storage device. 
-> There is no parity and backup in Level 0.



 RAID 1: 
-> RAID 1 uses mirroring techniques. When data is sent to a RAID controller, it sends a copy of data to all the disks in the array. 
-> RAID level 1 is also called mirroring and provides 100% redundancy in case of a failure. 



 RAID 2: 
-> RAID 2 records Error Correction Code using Hamming distance for its data, striped on different disks. 
-> Like level 0, each data bit in a word is recorded on a separate disk and ECC codes of the data words are stored on a different set disks. 
-> Due to its complex structure and high cost, RAID 2 is not commercially available.



 RAID 3: 
-> RAID 3 stripes the data onto multiple disks. 
-> The parity bit generated for data word is stored on a different disk. 
-> This technique makes it to overcome single disk failures.


 RAID 4: 
-> In this level, an entire block of data is written onto data disks and then the parity is generated and stored on a different disk. 
-> Note that level 3 uses byte-level striping, whereas level 4 uses block-level striping. 
-> Both level 3 and level 4 require at least three disks to implement RAID.



 RAID 5: 
-> RAID 5 writes whole data blocks onto different disks, but the parity bits generated for data block stripe are distributed among all the 
        data disks rather than storing them on a different dedicated disk. 


 RAID 6: 
-> RAID 6 is an extension of level 5. 
-> In this level, two independent parities are generated and stored in distributed fashion among multiple disks. 
-> Two parities provide additional fault tolerance. 
-> This level requires at least four disk drives to implement RAID.



FILE STRUCTURE:


-> Relative data and information is stored collectively in file formats. 
-> A file is a sequence of records stored in binary format. 
-> A disk drive is formatted into several blocks that can store records. 
-> File records are mapped onto those disk blocks.


File Organization:

-> File Organization defines how file records are mapped onto disk blocks. 


-> We have four types of File Organization to organize file records: 
1. Heap File Organization
2. Sequential File Organization
3. Hash File Organization
4. Clustered File Organization




Heap File Organization:

-> When a file is created using Heap File Organization, the Operating System allocates memory area to that file without any further accounting details. 
-> File records can be placed anywhere in that memory area. 
-> It is the responsibility of the software to manage the records. 
-> Heap File does not support any ordering, sequencing, or indexing on its own.



Sequential File Organization:

-> Every file record contains a data field (attribute) to uniquely identify that record. 
-> In sequential file organization, records are placed in the file in some sequential order based on the unique key field or search key. 
-> Practically, it is not possible to store all the records sequentially in physical form.



Hash File Organization:

-> Hash File Organization uses Hash function computation on some fields of the records. 
-> The output of the hash function determines the location of disk block where the records are to be placed.



Clustered File Organization:

-> Clustered file organization is not considered good for large databases. 
-> In this mechanism, related records from one or more relations are kept in the same disk block, 
        that is, the ordering of records is not based on primary key or search key. 




File Operations:

Operations on database files can be broadly classified into two categories:
 Update Operations
 Retrieval Operations


-> Update operations change the data values by insertion, deletion, or update. 
-> Retrieval operations, on the other hand, do not alter the data but retrieve them after optional conditional filtering. 

-> In both types of operations, selection plays a significant role. 
-> Other than creation and deletion of a file, there could be several operations, which can be done on files.


 Open: 
-> A file can be opened in one of the two modes, read mode or write mode. 
-> In read mode, the operating system does not allow anyone to alter data. 
-> In other words, data is read only. 

-> Files opened in read mode can be shared among several entities. 
-> Write mode allows data modification. 
-> Files opened in write mode can be read but cannot be shared.


 Locate: 
-> Every file has a file pointer, which tells the current position where the data is to be read or written. 
-> This pointer can be adjusted accordingly. 
-> Using find (seek) operation, it can be moved forward or backward.


 Read: 
-> By default, when files are opened in read mode, the file pointer points to the beginning of the file. 
-> There are options where the user can tell the operating system where to locate the file pointer at the time of opening a file. 
-> The very next data to the file pointer is read.



 Write: 
-> User can select to open a file in write mode, which enables them to edit its contents. 
-> It can be deletion, insertion, or modification. 
-> The file pointer can be located at the time of opening or can be dynamically changed if the operating system allows to do so.


 Close: 
-> This is the most important operation from the operating system’s point of view. 
-> When a request to close a file is generated, the operating system
o removes all the locks (if in shared mode),
o saves the data (if altered) to the secondary storage media, and 
o releases all the buffers and file handlers associated with the file.


-> The organization of data inside a file plays a major role here. 
-> The process to locate the file pointer to a desired record inside a file various based on whether the records are arranged sequentially or clustered.








































































